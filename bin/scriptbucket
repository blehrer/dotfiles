###################### Functions ####################################

# This gets the files that have changed on your local branch since you pushed to
# the upstream branch
function ffupdiff() {
    echo "Getting the diff between this branch and its upstream branch. ($(git rev-parse --abbrev-ref=strict @{u})) \n\n\n...\n\n\n";
    git fetch
    git diff --name-only @{u}
    echo "\n"
}
function fupdiff() {
    echo "Getting the diff between this branch and its upstream branch. ($(git rev-parse --abbrev-ref=strict @{u})) \n\n\n...\n\n\n";
    git diff --name-only @{u}
    echo "\n"
}

# This gets the diff between the current branch and its upstream branch
function updiff() {
    echo "Getting the diff between this branch and its upstream branch. ($(git rev-parse --abbrev-ref --symbolic-full-name @{u})) \n\n\n...\n\n\n";
    git fetch
    git diff --ignore-all-space $(git rev-parse --abbrev-ref --symbolic-full-name @{u});
    echo "\n"
}

function wsupdiff () {
  dir=$(pwd)
  cd $dir
  for d in `find . -type d -maxdepth 1`
  do
    echo "\n#########################\n"
    cd $dir/$d
    pwd
    git fetch
    git status
    updiff
    cd ..
  done;

}

function wsgst() {
  dir=$(pwd)
  cd $dir
  for d in `find . -type d -maxdepth 1`
  do
    echo "\n#########################\n"
    cd $dir/$d
    pwd
    git fetch
    git status
    cd ..
  done;
}

# This allows you to query the dictionary for words that match a given regex
function wordbowl() {
    cat /usr/share/dict/words | grep "$1"
}

# kill processes by loose name
function appkill() {
    kill -9 $(ps -ef | grep $1 | grep -v grep | awk '{print $2}')
}

touch! () {
  touch $1
  if test $? -gt 0; then
    mkdir -p $(echo $1 | rev | cut -d '/' -f2- | rev)
    touch $1
  fi
}

gv2svg() {
     cat $1 | dot | gvpack | neato -n2 -Tpng > ./gv.svg
     echo "./gv.svg created"
}

# add vim plugin as submodule of dotfiles
newVimPlugin() {
    cut_=$(which cut)

    # Depends on "brew install coreutils"
    [[ `uname` == "Darwin" ]] && cut_=/usr/local/homebrew/bin/gcut

    if [[ $1 =~ ^.+/.+/.+\.git$ ]]; then
	cd $DOTFILES_HOME
	longname=$(echo $1 | rev | $cut_ -d '/' -f 1,2 | $cut_ --complement -c 1-4 | rev)
	shortname=$(echo $longname | $cut_ -d '/' -f 2 )
	git submodule add --force --name "vim-plugin.$shortname" $1 ./homedir/.vim/pack/vendor/start/$shortname
	commitMsg="[vim-plugin] $longname"
	git commit -m "$commitMsg"
    else echo "Git repo format is incorrect (should end in namespace/repo.git)"
    fi
    vim -u NONE -c "helptags ~/.vim/pack/vendor/start/shortname/doc" -c q
}

zipdirs() {
    zip -r -X $1 $2 -x "*DS_Store" \*.un~ "**/local.properties" "**/override.substiutions.properties"
}

backup_workplace() {
    local outputPath=~/workplace.bk.$(date +%s).zip
    zip -r -X $outputPath $WORKPLACE \
        -x "*DS_Store" "*.un" "*/target/*" "*/allure-results/*" "*/output/*"
}

timezsh () {
	shell=${1-$SHELL}
	for i in $(seq 1 10)
	do
		/usr/bin/time $shell -i -c exit
	done
}

github-https-to-ssh() {
    echo '
    This script will attempt to change the url of _origin_
    for each git repository in the current directory.
        To continue, press _Y_
        Press Ctrl-c to interrupt.
        '
    read doit
    [[ $doit = Y ]] && {
        for i in $(ls); do;
            cd $i ;
            pwd ;
            [ -d .git ] && local remoteUri=`git remote get-url origin` ;
            [[ $remoteUri = https://github.com* ]] && {
                local newUri=`echo $remoteUri | sed -e 's/https...github.com./git@github.com:/g'`
                git remote set-url origin $newUri
                git remote get-url origin
            } || echo no change;
            cd .. ;
        done
    }
    unset doit
}

function @ghb() {
    local remoteUrl=`git remote get-url origin`
    [ $1 ] && local branch=$1 || local branch=`git branch --show-current`
    echo $remoteUrl/branch/$branch| sed 's/git@/https:\/\// ; s/com:/com\//; s/\s// ; s/\.git//'
}
function @ghc() {
    local remoteUrl=`git remote get-url origin`
    [ $1 ] && local commit=$1 || local commit=HEAD
    echo $remoteUrl/commit/$commit| sed 's/git@/https:\/\// ; s/com:/com\//; s/\s// ; s/\.git//'
}

function upfind() {

    local startingDirectory=$(pwd) searchDir=$(pwd) filename=($1) highestDirectory=($2) lastIteration=0 usage="

    upfind filename [highestDirectory]

    filename            The name of the file you are searching upwards for
    highestDirectory    The directory to stop at, when searching upwards for a file.
                            Optional. Defaults to the parent of the closest .git folder

    "

    [ -z $filename ] && {
        echo $usage
        return 1
    }
    [ $lastIteration = 0 ] && {
        while [[ $lastIteration == 0 ]]; do
            (([ -z $highestDirectory ] && [ -d $searchDir/.git ]) ||
                [[ `readlink -f $searchDir` = `readlink -f $highestDirectory` ]]) &&
                lastIteration=1
            result=`find $searchDir -maxdepth 1 -type f -name $filename`
            if [ -z $result ]; then
                [[ $lastIteration = 1 ]] && break
                searchDir+="/.."
            else
                readlink -f $result
                return $?
            fi
        done

        alt=`readlink -f $searchDir`
        tld=${highestDirectory:-$alt}
        echo "$filename was not found in the subtree from $startingDirectory to $tld"
        return 1
    }
}

function filetypes() {
    usage="
    Get the filetypes and dotfile names, recursively

    filetypes <options>

    -h  print this
    -d  directory to search in (required)
    -e  print as regular expression
    "

    while getopts 'hd:e' 'OPTKEY'; do
        case ${OPTKEY} in
        'h')
            echo $usage
            return
            ;;
        'd')
            local dir=$OPTARG
            ;;
        'e')
            local asRegex=1
            ;;
        esac
    done

    [ $dir ] || {
        echo $usage
        return 1
    }
    local rv=$(ag --ignore node_modules --files-with-matches . $dir | sed -e 's/.*\.//g' | sort -u)
    [[ $asRegex = 1 ]] &&  rv=$(echo $rv | tr '\n' '|' |  rev | cut -c 2- | rev)
    echo $rv
    return
}
